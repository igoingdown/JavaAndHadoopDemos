# CCI150 解题思路

1. 数组与字符串 
	1. 确定字符串所有字符都相同
		* SameCharOfString
		* 记录第一个字符，遍历所有字符，如果不同则返回false。
	2. 用C实现字符串反转
		* TP
	3. 判断一个字符串能否重新排列成另一个字符串
		* Hashmap
	4. 将字符串中的空格转换为"%20"
	5. 压缩字符串
		* CompressString
		* TP
	6. 右旋N*N的矩阵
		* 旋转操作是中心对称操作，可以通过一次轴对称和一次对角线变换（中心对称）实现
	7. 矩阵清零
		* 使用每行的第一列作为整行的flag，第一列的flag单独保存
	8. 调用一次`isSubstring`判断一个字符串是否为另一个字符串的旋转
		* 假设s1是s2的旋转字符串，设x为前一段，y为后一段。s1 = "xy", s2 = "yx", 则s2一定是"s1s1"即"xyxy"的子串。
	
2. 链表
	1. 删除无序链表中的重复节点
		* 允许使用多余空间时可以使用hashset
		* 不允许使用多余空间可以使用TP
	2. 删除单链表中倒数第K个节点
		* TP，注意边界条件，如删除的是尾节点和头节点，或者链表长度不够的情况
	3. 删除单链表中间某个节点
		* 将val修改为next的val，next修改为next的next，删除之前的next。
	4. 分割链表
		* TP，遍历原始链表，将其按值的大小分配到两个表的尾部，最后连上两个链表
	5. 链表加法
		* TP，注意进位
		* 当正向存储时，可以先将链表逆序然后做加法，最后转为正序表示
	6. 链表环起点
		* TP
	7. 检查链表是否为回文
		* PalindromeList
		* TP，令存一份链表的逆序版本，比较两个链表的前半段
		* TP + 栈

3. 栈和队列
	1. 使用定长数组实现三个栈
		* 每个栈固定长度`ThreeStackInOneArrayFixedPartition`
		* 每个栈不固定长度，可以通过移动其他栈中的元素提高数组空间利用率`ThreeStackInOneArrayRelaxPartition`，
		还可以使用双向链表来做，但是空间回收还是比较麻烦
	2. 带有min的栈
		* 使用递减栈
	3. 栈集合的push、pop以及popAt操作实现
		* 使用list和stack两种数据结构
	4. 汉诺塔
		* 递归。将n-1个上层元素移到buffer，将最底层的元素移到destination，再将buffer视为源，移到destination。
	5. 双栈实现队列
		* 双栈呈"U"型结构
	6. 对栈进行升序排序，只能使用另一个栈作为buffer辅助排序。
		* 将buffer排为降序，每次将stack的栈顶插到buffer的适当位置
	7. 领养动物
		* 必须领养队头，若指定动物类型，必须领养相应类型动物的队头
		* 两个queue，分别存两种动物的队列
		
4. 树和图
	1. 判定平衡树
		* 深度为-1则不平衡，否则返回正确的深度。
	2. 跟定有向图，找出两个节点之前是否存在路径
		* DFS
		* BFS，无需分层，单个queue即可
	3. 根据升序数组构造最浅二叉树
		* 递归，每次选中值作为根节点，两侧分别为左子树和右子树
	4. 将二叉树的每一层转为一个链表
		* 递归
		* BFS，这个方法更直观
	5. 判定BST
		* 中序遍历，记录上次访问的节点的引用
		* 递归，传入每个子树的上界和下界
	6. 寻找中序遍历的下一个节点，每个节点保存有指向父节点的指针
		* 有右子，返回右子树最左侧节点
		* 无右子，找到第一个不是父节点右子的节点，返回其父节点
		* 将寻找最左侧节点的过程单独拿出来，封装为API，结构更清晰。
	7. 两个节点的最低公共祖先节点
		* 递归
		* 首先分为BST和普通二叉树
		* 对于普通二叉树有两种方式
			1. 对于每个上层节点，查看两个节点分布在该节点的哪个子树上，缺点是存在大量重复计算
			2. 自下而上冒泡方式，包装结果，区分两种难以区分开的情况（一个节点在另一个的子树上和一个节点在树上，
			另一个节点不在）。 **被大佬教育了！要深入理解思路，不要注重tricky的表示，要注重思维的表达！！**
		* 对于普通树，可以分别找path，找出两个path的最后一个公共节点
		* 若每个节点存有指向父节点的指针，这个题就转化为链表的第一个公共节点
	8. 判断一个小树是否为另一个大树的子树
		* 根据中序、前序和后序遍历的规律转化为字符串匹配，先通过遍历将树序列化，如果小树的前序（后序）和中序遍历串是大树相应
		遍历串的子串，则小树是大树的子树。时间复杂度为O(m + n)，空间复杂度为O(m + n)
		* 递归匹配，时间复杂度为O(mn)，空间复杂度为O(logM + logN)。
		* 深入比较两个方法的时间和空间复杂度，能让面试官耳目一新！
	9. Path Sum IV
		* 递归

5. 位操作
	1. 位覆盖
	2. 浮点数的十进制转2进制
	3. 二进制下1的总数不变，找稍大和稍小的那个数
	4. 用`n & (n - 1)`判断n是否为2的某次幂
		* 还可以通过循环，逐个将n中低位的1消去，最后n会变为0
	5. 判断两个数的二进制差异位的个数
		* 异或
		* 之后又两种方式
			* 右移或左移查看1的个数
			* 利用上题的规律逐个减少1的个数并计数
	6. 二进制下的奇偶位互换
		* 通过掩码分别提取偶数位和奇数位，偶数位右移，奇数位左移，再并一下就是结果
	7. 找missing num
		* 异或，转为single num问题
		* 加和，再挨个减
		* 对于bit表示的数组可以递归解决，关键在于发现每次减少一半的输入，对于相应位是1还是0，扔到不同的数组，
		比较两个数组的大小就可以知道缺失值该位的值。
	8. 使用位操作在屏幕上绘制线条

6. 智力题
	1. 精量天平和特定质量的药丸，通过添加不同数量的药丸，查看最后多出的质量即可分辨出来
	2. 黑白棋盘，抹掉对角线两个角落，一张骨牌能覆盖连着的两个格子，一张骨牌一定是盖着黑白两个格，锯掉的两个
	格式同颜色的格，因此最后肯定不能完全覆盖。
	3. 5L和3L的水壶各一个，量出1L、2L、3L、4L水
	4. 看颜色，递归求解
	5. 最差解补偿，每次扔第一个蛋都应该减少第二个蛋扔的次数
	6. 储物柜，因式质分解，因式分解

7. 数学与概率
	1. 投篮
		* 概率问题，分清得分情况，然后求概率
	2. 多边形多蚂蚁的碰撞概率
		* 只有顺时针和逆时针两种情况不相撞，求概率
	3. 坐标系上的两条线是否相交
		* 看斜率是否相同
	4. 用加法实现减法、乘法、除法
		* 关键在于减法的实现
	5. 找一条直线将坐标系上的两个正方形平分
		* 关键在于平分正方形的直线一定过中心
	6. 找出经过点数最多的直线
		* 注意直线对象的设计，包括斜率、是否垂直和偏执。直线的比较尤其是斜率的比较也要注意，
		斜率差小于特定值epsilon即可。
		* O($N^2$)的复杂度跑不掉的
	7. 丑数
		* 只有之前的解可以生成后面的解，记录上一次生成解的位置不断更新即可
		* 当基数较多时可以用堆优化

8. OOD

9. 递归和动态规划
	1. 爬楼梯
		* 递归：指数级时间复杂度
		* DP
	2. 机器人走路
		* DP
		* math, 共要走的步数为（X+Y），向右走的步数为X，组合数就是解。
	3. 递增数组中查找与index相同的元素
		* BS
		* 递归。数组有重复元素时，无法判断应该往哪个方向移动，两个方向都要检索，但是可以根据已知情况缩小检索范围。
		检索左侧时，`high`变为`min(nums[mid], mid - 1)`，检索右侧时，`low`变为`max(mid + 1, nums[mid])`
	4. 集合所有子集
		* dfs
		* 组合数学，子集共有2^N个，遍历每个数，将其转换为集合即可，用位操作的思想
	5. 字符串的所有可能组合
		* dfs
	6. 所有合法括号组合
		* dfs
	7. 颜色填充
		* dfs
	8. Coin Change
		* DP
	9. 八皇后
		* dfs
	10. 堆箱子，要求上层的箱子的长宽高都小于下层的箱子
		* 先排序，在DFS+memo，时间复杂度O(N^2);
		* 背包问题
	11. 布尔表达式加括号改变运算顺序得到特定的结果，加括号的方式
		* 递归
		* 递归 + memo
		* 递归 + memo + Catalan数优化
0. 扩展性与内存限制
	
1. 排序与查找
	1. merge两个排序数组
	2. 字符串数组排序，变位词相邻
		* 基于普通排序时间复杂度为O(NlogN)
		* 基于桶排序时间复杂度O(N)
	3. 旋转数组中查找元素,leetcode 33/81
		* 先判断在上边还是在下边。使用`nums[mid]`和`nums[low]`的大小关系来判断
	4. 对大小为20GB，每行一个字符串的文本文件排序
		* 外排序。切成内存能容纳的小块排序，排完以文件存到硬盘。全部小块排完，维护文件指针，堆排序，
		选择最小的字符串写入最终结果文件。
	5. 在被空串分离的排序字符串数组中查找字符串
		* 二分查找变种1：
			1. 判断low和high是否为结果
			2. 判断mid是否为target
			3. mid为空，high--；
			4. mid不为空，该往哪移往哪移
		* 二分查找变种2：mid为空时将mid挪到离其最近的非空串
			* *注意mid位空时找left和right的循环过程容易出bug*
	6. 行列均递增的矩阵中查找
		* 从右上方开始找，沿着对角线方向找，一次遍历可以将范围缩减一行或者一列
		* 二分查找变种：利用对角线严格递增的性质，先找对角线上的下界，然后递归查找左下区域和右上区域。
	7. 叠罗汉（二维最长递增子序列）
		* sort之后的序列与原序列求LCS
		* 直接DP求最长递增子序列，O(N^2)。
		* 还有O(NlogN)的解法！
	8. 读取数据流，并随时记录秩。BST的应用
		* 使用一维数组可以，但是插入麻烦
		* 使用BST可以，不平衡也可以，平衡的话可以说说红黑树的思路

2. 测试

3. C和C++
	1. 读取文件最后的K行
		* 使用循环数组
	2. Hashmap和map
	3. 虚函数
	4. 深拷贝和浅拷贝
		* 浅拷贝将对象的成员的值拷贝到另一个对象中，而深拷贝除了拷贝所有成员的值，
		还会进一步拷贝所有指针对象
	5. volatile关键字
		* 声明"易变"，防止编译优化。例子一定要搞懂！作为经典示例。
			```c++
			int opt = 1;
			void foo() {
				start:
					if (opt == 1) goto start;
					else break;
			}
			```
			可能被优化为：
			```c++
			void foo() {
			start:
				int opt = 1;
				if (true) goto start;
			```
			这会导致死循环，这是我们不想看到的！这个例子非常好！
	6. 虚析构函数的作用
		经典例子：基类指针指向子类的对象
	7. 深拷贝树
		* 递归拷贝，hashmap记录已经拷贝的节点
	8. 实现智能指针类模板
		* 模板类变量成员：对象指针和对象引用计数的指针（**捆绑销售**！）。
		* 实现构造、析构、拷贝构造、赋值号重载函数。
		* 赋值号重载要考虑原来指向的对象和赋值后应该指向的对象是否为相同对象，相同的话类似拷贝构造函数，不同的话原引用对象引用计数减1（可能引发原引用对象的析构），新引用对象引用计数+1.
	9. 实现支持4B（或者8B）对齐mallo和free函数
		* C++实现有bug！！
	10. 实现为二维数组分配内存的专用malloc函数，要求malloc调用次数很少
		* 调用一次malloc即可，N行M列矩阵，分配能容纳N * (M+1)个数的内存。
		* 多出来一列指向每行的其实位置。

4. Java
	1. 构造函数设为private作用是什么
		* 不能继承
		* 要创建类对象，就要向外提供public的static方法，如工厂模式
	2. try-catch-finally的代码执行顺序
	3. final、finally和finalize的区别
		* final：控制函数、变量或类是否"可更改"
		* finally： try-catch-finally异常控制流的一部分
		* finalize： GC确定可以销毁一个对象时，销毁之前会调用finalize方法来清理资源，如关闭文件。
	4. c++模板和java的泛型的区别
		* 理解不够深刻！！！这是给自己挖坑……
	5. java的对象反射解释，用途
		* 非常迷！！
	6. 实现循环列表
	
5. 数据库

6. 线程与锁
	1. 进程、线程和协程的区别
		* 进程：
		* 线程：
		* 协程：
	2. 上下文切换时间的测定
	3. 哲学家就餐问题
		* 只拿到一只筷子就放下
		* 相当于用抢占的方式避免死锁
	4. 设计一个只有在不可能发生死锁的情况下才提供锁
		* 很高深的样子……不懂！！
	5. 用锁实现每个线程分别调用不同的函数，并保证函数调用顺序不乱
		* 可能会考到！要重点再看看！
	6. 同步方法和普通方法对于线程并发的约束
7. 中等难题
	1. 位运算实现两个数的交换
	2. 判断哪个玩家赢了井字游戏
		* 方法一：牺牲启动时间，事先将所有可能的棋盘及结果算好，存入hash表。对棋盘采用3进制hash，因为每个格子有3中情况（空，X和O），运行时只要计算棋盘hash值作为key查询hash表即可。
		* 方法二：易于事先，先查行，再差列，最后查两个对角线，只要全为X（或O），就返回X（或O）。
	3. n阶乘尾部的0的个数
		* 主要看从1到n所有数的因子中有多少个5，因为5 * 2 = 10， 没出现一个因子5，必定会出现至少两个2，所以2不是决定因素，而5才是。
		* 北邮ACM校赛题目。
		* 两种方法：
			1. 计算小于等于n的5的指数幂，然后将指数从1加到x，res加上`n/幂`。
			2. 初始`count = n / 5`, 随后逐渐减小count, `count /= 5`，直到`count = 0`,res就是所有count加起来。
	4. 不使用比较运算符实现max函数。
		* `max(a,b)`就是A和B中选择一个,转换为乘积形式`res = a * k + b * q`，k和q其中一个是1另一个为0。
		* 根据a,b和a-b的符号画真值表有助于理解，但是自己想还是想不明白
	5. 珠玑妙算
		* 颜色和位置都相同为猜中，颜色同、位置不同伪猜中，统计猜中和伪猜中的个数。
		* 按颜色分组，统计两者的频率，取较小值累计，减掉猜中的个数，就是伪猜中的个数。
	6. 部分无序数组，找出失序部分的起点和终点
		* 找出开始和末尾失序的第一个数，
		* 分别找出中间部分的最小值与最大值
		* 在起始部分找中间部分最小值的下界就是失序起点
		* 在末尾部分找中间部分最大值的上界就是失序终点
	7. 整数的英文描述
		* 3位一组
		* 每组设置不同的单位
		* 描述三位以内的整数
	8. 最大连续子数组和
	9. 频率查询
		* 单词查询：访问一次文件即可
		* 频繁查询：构建HashMap缓存
	0. XML编码
		* 递归编码
	1. 给定`rand(5)`，设计`rand(7)`
		* 取两次`rand(5)`的结果加和，小于7输出，属于不定次随机数生成
	2. Two Sum
		* TP
	3. 将二叉树转为双向链表
		* 递归：
			1. 递归将左子树和右子树分别转为链表
			2. 链接左侧部分、root和右侧部分
			3. 若不使用双向循环链表，链接的时候需要先遍历找到左半部分的尾节点，每个叶子节点在这个过程中会被访问D次，时间复杂度为O(N^2).
			4. 使用双向循环链表可以在O(1)的时间复杂度内完成链接
	4. 给定字典和字符序列，找出最佳字符序列拆分方法，即拆分后无法辨识字符最少
		* 递归：记录start_index, word和dict，每次决定将start_index位置的字符与之前拼在一起还是与后续拼在一起，取较小的那个。
		* 可以适应memo和Trie优化

8. 高难度题
	1. 不使用算术运算符实现整数加法
		* 递归：
			1. 分别用`^`和`&`操作符计算无进位sum和纯进位
			2. 递归相加
			3. 递归过程中，进位中1越来越少（因为左移和全1才进位的原因）
	2. 洗牌
		* 思路是：欲洗N张牌，先洗N-1张，将第N张与前面N-1张牌中的一张随机调换，递归和迭代均可实现
	3. 从n个数中随机选出m个数，要求每个数被选中的概率相同
		* 利用覆盖和不覆盖的关系推概率
		* 是leetcode382的升级版，leetcode382是n个数随机取一个，这里是随机取m个，并且要求概率相同。其实同理。
		* 先取前m个数，对于之后的每个数`nums[i]`，产生一个随机数k属于`[0, i]`区间，如果k小于m，将结果的第k个数覆盖。
		* 计算每个数被保留到结果中（不被覆盖）的概率都是`m/n`。
	4. 数出`[0, n]`区间所有数中数字`2`出现的次数。
		* 数学题。递归
	5. 超大文本中，找出任意两个单词的最短距离
		* TP：
			1. 分别使用lastPos1和lastPos2记录两个单词上次出现的位置，初始化为-1
			2. 遍历每个单词，如果是word1，比较新的位置与lastPos2的差和dis；如果是word2，比较新的位置与lastPos1的差和dis。
	6. 给定10亿个数字，找出其中最小的100万个数字
		* 堆：适合更大规模的排序
		* 快排：
	7. 给定一组单词，找出最长的可以由其他单词拼成的单词
		* 按长度从长到短排序
		* 划分字符串，若左侧字符串在词表中，递归+memo检测右侧是否可以由单词拼成
		* memo只要记录失败的单词即可，因为如果有检测成功，一定第一个通过检测的右侧字符串，会立即输出结果。
	8. 单串多模匹配
		* 后缀树：Suffix Tree（与前缀树Trie相对）：
			1. indices记录从该节点出发的后缀起始index，children记录子节点，是一个长度为256的节点数组，同Trie
			2. 节点Node和树Tree分开实现
			3. 递归插入string和查找string
		* 后缀树通过缓存母串，减少匹配时间复杂度，前缀树通过缓存模式串的关系减少匹配复杂度，多模匹配中后缀树更适合。
	9. 流中读取数字，随时查询中位数
		* 两个堆，大根堆装较小的一半，小根堆装较大的一半，模拟漏斗结构
		* 一个trick是保证大根堆的size >= 小根堆的size
	10. leetcode 126 + 127， word ladder
	11. Maximal Square
		* 类似Leetcode 85，远比leetcode 85简单
		* 遍历所有可能的square，判断该square是否合法
		* 一个trick可以将O(N^4)的时间复杂度下降到O(N^3)：通过预处理判断每个单元格下方和右侧的黑格个数（包含自身）。
	12. 最大子矩阵和
		* 暴力解法：遍历所有可能的矩阵，通过预先计算好的前缀和在O(1)的时间复杂度内可以计算出每个矩阵的和，O(N^4)
		* 类比最大子数组和：固定行首行尾，将一列视为一个数组，转化为最大子数组和问题，O(N^3)
	13. 在给定词典中，选取单词，构建最大的字母矩阵，要求每行构成单词，每列也构成单词
		* Trie的完美应用！

10. BUPT_ACM_PRE
	1. leetcode 48
	2. subsequence "bupt"出现的次数
	3. 辗转相除法求GCD，斐波那契数列
	4. 有阻断，有方向的maze，求起点到终点的最短距离，参考直通硅谷题目



# CCI150 解题思路

1. 数组与字符串 
	1. 确定字符串所有字符都相同
		* SameCharOfString
		* 记录第一个字符，遍历所有字符，如果不同则返回false。
	2. 用C实现字符串反转
		* TP
	3. 判断一个字符串能否重新排列成另一个字符串
		* Hashmap
	4. 将字符串中的空格转换为"%20"
	5. 压缩字符串
		* CompressString
		* TP
	6. 右旋N*N的矩阵
		* 旋转操作是中心对称操作，可以通过一次轴对称和一次对角线变换（中心对称）实现
	7. 矩阵清零
		* 使用每行的第一列作为整行的flag，第一列的flag单独保存
	8. 调用一次`isSubstring`判断一个字符串是否为另一个字符串的旋转
		* 假设s1是s2的旋转字符串，设x为前一段，y为后一段。s1 = "xy", s2 = "yx", 则s2一定是"s1s1"即"xyxy"的子串。
	
2. 链表
	1. 删除无序链表中的重复节点
		* 允许使用多余空间时可以使用hashset
		* 不允许使用多余空间可以使用TP
	2. 删除单链表中倒数第K个节点
		* TP，注意边界条件，如删除的是尾节点和头节点，或者链表长度不够的情况
	3. 删除单链表中间某个节点
		* 将val修改为next的val，next修改为next的next，删除之前的next。
	4. 分割链表
		* TP，遍历原始链表，将其按值的大小分配到两个表的尾部，最后连上两个链表
	5. 链表加法
		* TP，注意进位
		* 当正向存储时，可以先将链表逆序然后做加法，最后转为正序表示
	6. 链表环起点
		* TP
	7. 检查链表是否为回文
		* PalindromeList
		* TP，令存一份链表的逆序版本，比较两个链表的前半段
		* TP + 栈

3. 栈和队列
	1. 使用定长数组实现三个栈
		* 每个栈固定长度`ThreeStackInOneArrayFixedPartition`
		* 每个栈不固定长度，可以通过移动其他栈中的元素提高数组空间利用率`ThreeStackInOneArrayRelaxPartition`，
		还可以使用双向链表来做，但是空间回收还是比较麻烦
	2. 带有min的栈
		* 使用递减栈
	3. 栈集合的push、pop以及popAt操作实现
		* 使用list和stack两种数据结构
	4. 汉诺塔
		* 递归。将n-1个上层元素移到buffer，将最底层的元素移到destination，再将buffer视为源，移到destination。
	5. 双栈实现队列
		* 双栈呈"U"型结构
	6. 对栈进行升序排序，只能使用另一个栈作为buffer辅助排序。
		* 将buffer排为降序，每次将stack的栈顶插到buffer的适当位置
	7. 领养动物
		* 必须领养队头，若指定动物类型，必须领养相应类型动物的队头
		* 两个queue，分别存两种动物的队列
		
4. 树和图
	1. 判定平衡树
		* 深度为-1则不平衡，否则返回正确的深度。
	2. 跟定有向图，找出两个节点之前是否存在路径
		* DFS
		* BFS，无需分层，单个queue即可
	3. 根据升序数组构造最浅二叉树
		* 递归，每次选中值作为根节点，两侧分别为左子树和右子树
	4. 将二叉树的每一层转为一个链表
		* 递归
		* BFS，这个方法更直观
	5. 判定BST
		* 中序遍历，记录上次访问的节点的引用
		* 递归，传入每个子树的上界和下界
	6. 寻找中序遍历的下一个节点，每个节点保存有指向父节点的指针
		* 有右子，返回右子树最左侧节点
		* 无右子，找到第一个不是父节点右子的节点，返回其父节点
		* 将寻找最左侧节点的过程单独拿出来，封装为API，结构更清晰。
	7. 两个节点的最低公共祖先节点
		* 递归
		* 首先分为BST和普通二叉树
		* 对于普通二叉树有两种方式
			1. 对于每个上层节点，查看两个节点分布在该节点的哪个子树上，缺点是存在大量重复计算
			2. 自下而上冒泡方式，包装结果，区分两种难以区分开的情况（一个节点在另一个的子树上和一个节点在树上，另一个节点不在）。
		* 对于普通树，可以分别找path，找出两个path的最后一个公共节点
		* 若每个节点存有指向父节点的指针，这个题就转化为链表的第一个公共节点
	8. 判断一个小树是否为另一个大树的子树
		* 根据中序、前序和后序遍历的规律转化为字符串匹配，先通过遍历将树序列化，如果小树的前序（后序）和中序遍历串是大树相应
		遍历串的子串，则小树是大树的子树。时间复杂度为O(m + n)，空间复杂度为O(m + n)
		* 递归匹配，时间复杂度为O(mn)，空间复杂度为O(logM + logN)。
		* 深入比较两个方法的时间和空间复杂度，能让面试官耳目一新！
	9. Path Sum IV
		* 递归

5. 位操作
	1. 位覆盖
	2. 浮点数的十进制转2进制
	3. 二进制下1的总数不变，找稍大和稍小的那个数
	4. 用`n & (n - 1)`判断n是否为2的某次幂
		* 还可以通过循环，逐个将n中低位的1消去，最后n会变为0
	5. 判断两个数的二进制差异位的个数
		* 异或
		* 之后又两种方式
			* 右移或左移查看1的个数
			* 利用上题的规律逐个减少1的个数并计数
	6. 二进制下的奇偶位互换
		* 通过掩码分别提取偶数位和奇数位，偶数位右移，奇数位左移，再并一下就是结果
	7. 找missing num
		* 异或，转为single num问题
		* 加和，再挨个减
		* 对于bit表示的数组可以递归解决，关键在于发现每次减少一半的输入，对于相应位是1还是0，扔到不同的数组，
		比较两个数组的大小就可以知道缺失值该位的值。
	8. 使用位操作在屏幕上绘制线条

6. 智力题
	1. 